<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>+1 Dither Tool</title>
    <!-- Загружаем библиотеки из CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.10/dist/tweakpane.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: row;
            height: 100vh;
            background-color: #333;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        .canvas-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #222;
            position: relative;
        }
        
        .controls {
            width: 250px;
            background-color: #444;
            padding: 10px;
            overflow-y: auto;
        }
        
        h2 {
            margin-top: 0;
            font-size: 18px;
        }
        
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
        }
        
        #video-preview {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            display: none;
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #video-preview video {
            max-width: 80%;
            max-height: 70%;
            margin-bottom: 20px;
        }
        
        #video-preview .buttons {
            display: flex;
            gap: 10px;
        }
        
        .preview-button {
            padding: 10px 20px;
            background-color: #2a9d8f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .preview-button:hover {
            background-color: #1d7d71;
        }
        
        .preview-button.cancel {
            background-color: #e76f51;
        }
        
        .preview-button.cancel:hover {
            background-color: #d65f41;
        }
        
        .fps-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            color: white;
            z-index: 100;
        }
        
        /* Стиль для индикатора прогресса конвертации */
        .conversion-progress {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            height: 4px;
            background-color: #444;
            display: none;
        }
        
        .conversion-progress-bar {
            height: 100%;
            width: 0%;
            background-color: #2a9d8f;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="canvas-area" id="canvas-container">
        <!-- Canvas будет добавлен сюда p5.js -->
        <div id="loading-indicator">Загрузка...</div>
    </div>
    
    <div class="controls" id="controls-container">
        <!-- Tweakpane будет добавлен сюда -->
        <input type="file" id="media-input" accept="image/*" style="display: none;">
    </div>
    
    <!-- Предпросмотр видео перед скачиванием -->
    <div id="video-preview">
        <video id="preview-player" controls></video>
        <div class="buttons">
            <button class="preview-button" id="download-video">Скачать видео</button>
            <button class="preview-button cancel" id="close-preview">Закрыть</button>
        </div>
    </div>

    <script>
        // Глобальные переменные
        let img;
        let video;
        let canvas;
        let pane;
        let isProcessing = false;
        let isVideoMode = false;
        let tempImg;
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recordingTimer;
        let videoBlob = null;
        let recordBtn;
        let recordingMonitor;
        let fps = 0;
        let lastFrameTime = 0;
        let lastFpsUpdate = 0;
        let ffmpegLoaded = false;
        let isConverting = false;
        
        // Константы
        const DITHER_TYPES = {
            'Ordered (Bayer)': 'Ordered (Bayer)',
            'Floyd-Steinberg': 'Floyd-Steinberg',
            'Atkinson': 'Atkinson',
            'Burkes': 'Burkes',
            'Sierra Lite': 'Sierra Lite',
            'JJN': 'JJN',
            'Chessboard': 'Chessboard',
            'Voronoi': 'Voronoi',
            'Maze': 'Maze',
            'Pixel Sorting': 'Pixel Sorting'
        };
        
        // Параметры для Tweakpane
        const PARAMS = {
            dither: {
                type: 'Ordered (Bayer)',
                scale: 4,
                useColor: false,
                invertColors: false
            },
            image: {
                brightness: 1.0,
                contrast: 1.0,
                saturation: 0.0,
                maxSize: 800
            },
            video: {
                play: function() {
                    if (video) {
                        video.play();
                        loop();
                    }
                },
                pause: function() {
                    if (video) {
                        video.pause();
                        noLoop();
                    }
                },
                fps: 30,
                recordFps: 15,
                recordButtonText: 'Записать видео',
                record: function() {
                    if (!isRecording) {
                        startRecording();
                    } else {
                        stopRecording();
                    }
                },
                recordingDuration: 0,
                showFPS: false,
                optimizeForRecording: true
            },
            buttons: {
                upload: function() {
                    document.getElementById('media-input').click();
                },
                savePNG: function() {
                    saveCanvas('dithered-image', 'png');
                }
            }
        };
        
        // p5.js setup function - запускается один раз при старте
        function setup() {
            console.log("Setup начат");
            
            // Создаем canvas и помещаем его в контейнер
            canvas = createCanvas(600, 600);
            canvas.parent('canvas-container');
            
            // Отключаем автоматическую перерисовку для повышения производительности
            noLoop();
            
            // Загружаем инициализируем начальное изображение
            createRandomImage();
            
            // Настраиваем Tweakpane
            setupTweakpane();
            
            // Применяем начальный эффект
            applyDither();
            
            // Настраиваем обработчик загрузки медиафайлов
            setupMediaUpload();
            
            // Создаем индикатор FPS
            createFPSIndicator();
            
            console.log("Setup завершен");
        }
        
        // Создаем случайное изображение для начальной демонстрации
        function createRandomImage() {
            // Создаем изображение размером с canvas для полного заполнения
            img = createImage(width, height);
            img.loadPixels();
            
            // Создаем узор из концентрических квадратов
            for (let i = 0; i < img.width; i++) {
                for (let j = 0; j < img.height; j++) {
                    let val = 0;
                    
                    // Создаем основной квадратный паттерн
                    const distToCenter = max(
                        abs(i - img.width/2) / (img.width/2),
                        abs(j - img.height/2) / (img.height/2)
                    );
                    
                    // Градиент от центра к краям
                    val = map(distToCenter, 0, 1, 255, 50);
                    
                    // Добавляем концентрические квадраты
                    const scaledDist = distToCenter * 15;
                    if (floor(scaledDist) % 2 === 0) {
                        val += 40;
                    }
                    
                    // Добавляем диагональные линии
                    if ((i + j) % 30 < 15) {
                        val -= 30;
                    }
                    
                    // Создаем шахматный узор в углах
                    const cornerDist = min(i, j, img.width - i, img.height - j) / 10;
                    if (cornerDist < 10 && ((floor(i/10) + floor(j/10)) % 2 === 0)) {
                        val += 50;
                    }
                    
                    // Ограничиваем значения
                    val = constrain(val, 0, 255);
                    
                    img.set(i, j, color(val));
                }
            }
            img.updatePixels();
            console.log("Создано демонстрационное изображение");
        }
        
        // Настройка панели Tweakpane
        function setupTweakpane() {
            console.log("Настройка Tweakpane");
            
            pane = new Tweakpane.Pane({
                title: 'Дизеринг',
                container: document.getElementById('controls-container')
            });
            
            // Папка для основных функций
            const mainFolder = pane.addFolder({
                title: 'Основные',
                expanded: true
            });
            
            // Кнопка для загрузки изображения
            mainFolder.addButton({
                title: 'Загрузить изображение'
            }).on('click', () => {
                document.getElementById('media-input').click();
            });
            
            // Папка для настроек дизеринга
            const ditherFolder = pane.addFolder({
                title: 'Дизеринг',
                expanded: true
            });
            
            // Выбор типа дизеринга
            ditherFolder.addInput(PARAMS.dither, 'type', {
                options: DITHER_TYPES
            }).on('change', () => {
                applyDither();
            });
            
            // Размер точек
            ditherFolder.addInput(PARAMS.dither, 'scale', {
                min: 1,
                max: 20,
                step: 1
            }).on('change', () => {
                applyDither();
            });
            
            // Переключатель цветного режима
            ditherFolder.addInput(PARAMS.dither, 'useColor', {
                label: 'Цветной режим'
            }).on('change', () => {
                applyDither();
            });
            
            // Инверсия цветов
            ditherFolder.addInput(PARAMS.dither, 'invertColors', {
                label: 'Инвертировать'
            }).on('change', () => {
                applyDither();
            });
            
            // Папка для настроек изображения
            const imageFolder = pane.addFolder({
                title: 'Изображение',
                expanded: true
            });
            
            // Яркость
            imageFolder.addInput(PARAMS.image, 'brightness', {
                min: 0,
                max: 2,
                step: 0.05
            }).on('change', () => {
                applyDither();
            });
            
            // Контраст
            imageFolder.addInput(PARAMS.image, 'contrast', {
                min: 0.1,
                max: 3,
                step: 0.05
            }).on('change', () => {
                applyDither();
            });
            
            // Папка для экспорта
            const exportFolder = pane.addFolder({
                title: 'Экспорт',
                expanded: true
            });
            
            // Кнопка сохранения
            exportFolder.addButton({
                title: 'Сохранить PNG'
            }).on('click', () => {
                PARAMS.buttons.savePNG();
            });
            
            console.log("Tweakpane настроен");
        }
        
        function setupMediaUpload() {
            const input = document.getElementById('media-input');
            input.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                showLoading(true);
                
                if (file.type.startsWith('video/')) {
                    loadVideoFile(file);
                } else if (file.type.startsWith('image/')) {
                    loadImageFile(file);
                } else {
                    console.error('Неподдерживаемый тип файла');
                    showLoading(false);
                }
            });
        }
        
        function loadVideoFile(file) {
            const url = URL.createObjectURL(file);
            
            // Удаляем старое видео, если есть
            if (video) {
                video.remove();
            }
            
            // Создаем новое видео
            video = createVideo(url, function() {
                console.log('Видео загружено');
                
                // Подгоняем размер canvas под размер видео
                let canvasSize = Math.min(window.innerWidth * 0.7, window.innerHeight * 0.8, 800);
                let ratio = video.width / video.height;
                resizeCanvas(canvasSize, canvasSize / ratio);
                
                // Отключаем звук и включаем зацикливание
                video.volume(0);
                video.loop();
                
                // Включаем режим видео
                isVideoMode = true;
                
                // Запускаем обработку кадров
                loop();
                
                showLoading(false);
            });
            
            video.hide();
        }
        
        function loadImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                loadImage(e.target.result, function(loaded) {
                    // Если изображение слишком большое, уменьшаем его
                    if (loaded.width > PARAMS.image.maxSize || loaded.height > PARAMS.image.maxSize) {
                        let ratio = loaded.width / loaded.height;
                        let newWidth, newHeight;
                        
                        if (loaded.width > loaded.height) {
                            newWidth = PARAMS.image.maxSize;
                            newHeight = PARAMS.image.maxSize / ratio;
                        } else {
                            newHeight = PARAMS.image.maxSize;
                            newWidth = PARAMS.image.maxSize * ratio;
                        }
                        
                        let resizeCanvas = createGraphics(newWidth, newHeight);
                        resizeCanvas.image(loaded, 0, 0, newWidth, newHeight);
                        img = resizeCanvas.get();
                    } else {
                        img = loaded;
                    }
                    
                    // Подгоняем размер canvas под размер изображения
                    let canvasSize = Math.min(window.innerWidth * 0.7, window.innerHeight * 0.8, 800);
                    let ratio = img.width / img.height;
                    resizeCanvas(canvasSize, canvasSize / ratio);
                    
                    // Выключаем режим видео
                    isVideoMode = false;
                    
                    applyDither();
                    showLoading(false);
                });
            };
            reader.readAsDataURL(file);
        }
        
        // Показать/скрыть индикатор загрузки
        function showLoading(show) {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) {
                indicator.style.display = show ? 'block' : 'none';
            }
        }
        
        // Применение эффекта дизеринга
        function applyDither() {
            // Предотвращаем повторный запуск если обработка уже идет
            if (isProcessing) {
                console.log("Обработка уже идет, игнорируем запрос");
                return;
            }
            
            // Проверяем, загружено ли изображение
            if (!img) {
                console.error("Изображение не загружено");
                background(50);
                fill(255);
                textSize(16);
                textAlign(CENTER, CENTER);
                text("Ошибка: изображение не загружено", width/2, height/2);
                return;
            }
            
            isProcessing = true;
            showLoading(true);
            
            try {
                // Применяем выбранный алгоритм дизеринга
                
                // Определяем цвет фона
                let bgColor = PARAMS.dither.invertColors ? 0 : 255;
                background(bgColor);
                
                // Специальная обработка экстремальных значений яркости
                if (PARAMS.image.brightness <= 0) {
                    // При яркости 0 - рисуем полностью черный экран
                    background(0);
                    isProcessing = false;
                    showLoading(false);
                    return;
                } else if (PARAMS.image.brightness >= 2) {
                    // При яркости >=2 - рисуем полностью белый экран
                    background(255);
                    isProcessing = false;
                    showLoading(false);
                    return;
                }
                
                // Выбор алгоритма дизеринга
                switch(PARAMS.dither.type) {
                    case 'Ordered (Bayer)':
                        applyOrderedDither();
                        break;
                    case 'Floyd-Steinberg':
                        applyFloydSteinberg();
                        break;
                    case 'Atkinson':
                        applyAtkinson();
                        break;
                    case 'Burkes':
                        applyBurkes();
                        break;
                    case 'Sierra Lite':
                        applySierraLite();
                        break;
                    case 'JJN':
                        applyJJN();
                        break;
                    case 'Chessboard':
                        applyChessboard();
                        break;
                    case 'Voronoi':
                        applyVoronoi();
                        break;
                    case 'Maze':
                        applyMaze();
                        break;
                    case 'Pixel Sorting':
                        applyPixelSorting();
                        break;
                    default:
                        console.log("Неизвестный тип дизеринга:", PARAMS.dither.type);
                        applyOrderedDither();
                }
                
            } catch (error) {
                console.error("Ошибка при применении дизеринга:", error);
                background(40);
                fill(255, 0, 0);
                textSize(16);
                textAlign(CENTER, CENTER);
                text("Ошибка: " + error.message, width/2, height/2);
            } finally {
                isProcessing = false;
                showLoading(false);
            }
        }
        
        // Применение алгоритма Ordered Dither (Bayer)
        function applyOrderedDither() {
            console.log("Применяем Ordered Dither");
            
            // Матрица Байера 4x4
            const bayerMatrix = [
                [0, 8, 2, 10],
                [12, 4, 14, 6],
                [3, 11, 1, 9],
                [15, 7, 13, 5]
            ];
            
            // Создаем копию изображения для обработки с учетом масштаба
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            
            // Вычисляем количество ячеек на холсте
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            // Создаем буфер для хранения значений пикселей
            const buffer = new Array(h).fill().map(() => 
                new Array(w).fill().map(() => ({ r: 0, g: 0, b: 0 }))
            );
            
            // Заполняем буфер исходными значениями и применяем яркость/контраст
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Получаем цвет из оригинального изображения с учетом масштаба
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    // Если включена инверсия, инвертируем значения
                    if (PARAMS.dither.invertColors) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }
                    
                    buffer[y][x] = {
                        r: constrain(r, 0, 255),
                        g: constrain(g, 0, 255),
                        b: constrain(b, 0, 255)
                    };
                }
            }
            
            // Применяем дизеринг с использованием матрицы Байера
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Определяем порог из матрицы Байера
                    const threshold = (bayerMatrix[y % 4][x % 4] / 16) * 255;
                    
                    const oldPixel = buffer[y][x];
                    const newPixel = {
                        r: oldPixel.r < threshold ? 0 : 255,
                        g: oldPixel.g < threshold ? 0 : 255,
                        b: oldPixel.b < threshold ? 0 : 255
                    };
                    
                    // Записываем новый пиксель в изображение
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = newPixel.r;
                    tempImg.pixels[i + 1] = newPixel.g;
                    tempImg.pixels[i + 2] = newPixel.b;
                    tempImg.pixels[i + 3] = 255;
                }
            }
            
            tempImg.updatePixels();
            
            // Отображаем результат с масштабированием
            background(PARAMS.dither.invertColors ? 255 : 0);
            
            // Рисуем каждый пиксель как прямоугольник нужного размера
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const c = color(
                        tempImg.pixels[i],
                        tempImg.pixels[i + 1],
                        tempImg.pixels[i + 2]
                    );
                    noStroke();
                    fill(c);
                    rect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Применение алгоритма Floyd-Steinberg
        function applyFloydSteinberg() {
            console.log("Применяем Floyd-Steinberg");
            
            // Создаем копию изображения для обработки с учетом масштаба
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            
            // Вычисляем количество ячеек на холсте
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            // Создаем буфер для хранения значений пикселей
            const buffer = new Array(h).fill().map(() => 
                new Array(w).fill().map(() => ({ r: 0, g: 0, b: 0 }))
            );
            
            // Заполняем буфер исходными значениями и применяем яркость/контраст
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Получаем цвет из оригинального изображения с учетом масштаба
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    // Если включена инверсия, инвертируем значения
                    if (PARAMS.dither.invertColors) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }
                    
                    buffer[y][x] = {
                        r: constrain(r, 0, 255),
                        g: constrain(g, 0, 255),
                        b: constrain(b, 0, 255)
                    };
                }
            }
            
            // Применяем дизеринг
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const oldPixel = buffer[y][x];
                    const newPixel = {
                        r: oldPixel.r < 128 ? 0 : 255,
                        g: oldPixel.g < 128 ? 0 : 255,
                        b: oldPixel.b < 128 ? 0 : 255
                    };
                    
                    // Записываем новый пиксель в изображение
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = newPixel.r;
                    tempImg.pixels[i + 1] = newPixel.g;
                    tempImg.pixels[i + 2] = newPixel.b;
                    tempImg.pixels[i + 3] = 255;
                    
                    // Вычисляем ошибки
                    const errorR = oldPixel.r - newPixel.r;
                    const errorG = oldPixel.g - newPixel.g;
                    const errorB = oldPixel.b - newPixel.b;
                    
                    // Распространяем ошибки на соседние пиксели
                    if (x < w - 1) {
                        buffer[y][x + 1].r += errorR * 7/16;
                        buffer[y][x + 1].g += errorG * 7/16;
                        buffer[y][x + 1].b += errorB * 7/16;
                    }
                    
                    if (y < h - 1) {
                        if (x > 0) {
                            buffer[y + 1][x - 1].r += errorR * 3/16;
                            buffer[y + 1][x - 1].g += errorG * 3/16;
                            buffer[y + 1][x - 1].b += errorB * 3/16;
                        }
                        
                        buffer[y + 1][x].r += errorR * 5/16;
                        buffer[y + 1][x].g += errorG * 5/16;
                        buffer[y + 1][x].b += errorB * 5/16;
                        
                        if (x < w - 1) {
                            buffer[y + 1][x + 1].r += errorR * 1/16;
                            buffer[y + 1][x + 1].g += errorG * 1/16;
                            buffer[y + 1][x + 1].b += errorB * 1/16;
                        }
                    }
                }
            }
            
            tempImg.updatePixels();
            
            // Отображаем результат с масштабированием
            background(PARAMS.dither.invertColors ? 255 : 0);
            
            // Рисуем каждый пиксель как прямоугольник нужного размера
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const c = color(
                        tempImg.pixels[i],
                        tempImg.pixels[i + 1],
                        tempImg.pixels[i + 2]
                    );
                    noStroke();
                    fill(c);
                    rect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Применение алгоритма Аткинсона
        function applyAtkinson() {
            console.log("Применяем Atkinson");
            
            // Создаем копию изображения для обработки с учетом масштаба
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            
            // Вычисляем количество ячеек на холсте
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            // Создаем буфер для хранения значений пикселей
            const buffer = new Array(h).fill().map(() => 
                new Array(w).fill().map(() => ({ r: 0, g: 0, b: 0 }))
            );
            
            // Заполняем буфер исходными значениями и применяем яркость/контраст
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // Получаем цвет из оригинального изображения с учетом масштаба
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    // Если включена инверсия, инвертируем значения
                    if (PARAMS.dither.invertColors) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }
                    
                    buffer[y][x] = {
                        r: constrain(r, 0, 255),
                        g: constrain(g, 0, 255),
                        b: constrain(b, 0, 255)
                    };
                }
            }
            
            // Применяем дизеринг
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const oldPixel = buffer[y][x];
                    const newPixel = {
                        r: oldPixel.r < 128 ? 0 : 255,
                        g: oldPixel.g < 128 ? 0 : 255,
                        b: oldPixel.b < 128 ? 0 : 255
                    };
                    
                    // Записываем новый пиксель в изображение
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = newPixel.r;
                    tempImg.pixels[i + 1] = newPixel.g;
                    tempImg.pixels[i + 2] = newPixel.b;
                    tempImg.pixels[i + 3] = 255;
                    
                    // Вычисляем ошибки и делим на 8 (особенность алгоритма Аткинсона)
                    const errorR = (oldPixel.r - newPixel.r) / 8;
                    const errorG = (oldPixel.g - newPixel.g) / 8;
                    const errorB = (oldPixel.b - newPixel.b) / 8;
                    
                    // Распространяем ошибки по шаблону Аткинсона
                    const neighbors = [
                        [x + 1, y],     // право
                        [x + 2, y],     // право+1
                        [x - 1, y + 1], // нижний левый
                        [x, y + 1],     // низ
                        [x + 1, y + 1], // нижний правый
                        [x, y + 2]      // низ+1
                    ];
                    
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            buffer[ny][nx].r += errorR;
                            buffer[ny][nx].g += errorG;
                            buffer[ny][nx].b += errorB;
                        }
                    }
                }
            }
            
            tempImg.updatePixels();
            
            // Отображаем результат с масштабированием
            background(PARAMS.dither.invertColors ? 255 : 0);
            
            // Рисуем каждый пиксель как прямоугольник нужного размера
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const c = color(
                        tempImg.pixels[i],
                        tempImg.pixels[i + 1],
                        tempImg.pixels[i + 2]
                    );
                    noStroke();
                    fill(c);
                    rect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Алгоритм Burkes
        function applyBurkes() {
            console.log("Применяем Burkes");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            const buffer = new Array(h).fill().map(() => 
                new Array(w).fill().map(() => ({ r: 0, g: 0, b: 0 }))
            );
            
            // Заполняем буфер исходными значениями
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    if (PARAMS.dither.invertColors) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }
                    
                    buffer[y][x] = {
                        r: constrain(r, 0, 255),
                        g: constrain(g, 0, 255),
                        b: constrain(b, 0, 255)
                    };
                }
            }
            
            // Применяем дизеринг Burkes
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const oldPixel = buffer[y][x];
                    const newPixel = {
                        r: oldPixel.r < 128 ? 0 : 255,
                        g: oldPixel.g < 128 ? 0 : 255,
                        b: oldPixel.b < 128 ? 0 : 255
                    };
                    
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = newPixel.r;
                    tempImg.pixels[i + 1] = newPixel.g;
                    tempImg.pixels[i + 2] = newPixel.b;
                    tempImg.pixels[i + 3] = 255;
                    
                    // Вычисляем ошибки
                    const errorR = (oldPixel.r - newPixel.r) / 16;
                    const errorG = (oldPixel.g - newPixel.g) / 16;
                    const errorB = (oldPixel.b - newPixel.b) / 16;
                    
                    // Распространяем ошибки по схеме Burkes
                    if (x < w - 1) buffer[y][x + 1] = addError(buffer[y][x + 1], errorR * 8, errorG * 8, errorB * 8);
                    if (x < w - 2) buffer[y][x + 2] = addError(buffer[y][x + 2], errorR * 4, errorG * 4, errorB * 4);
                    
                    if (y < h - 1) {
                        if (x > 1) buffer[y + 1][x - 2] = addError(buffer[y + 1][x - 2], errorR * 2, errorG * 2, errorB * 2);
                        if (x > 0) buffer[y + 1][x - 1] = addError(buffer[y + 1][x - 1], errorR * 4, errorG * 4, errorB * 4);
                        buffer[y + 1][x] = addError(buffer[y + 1][x], errorR * 8, errorG * 8, errorB * 8);
                        if (x < w - 1) buffer[y + 1][x + 1] = addError(buffer[y + 1][x + 1], errorR * 4, errorG * 4, errorB * 4);
                        if (x < w - 2) buffer[y + 1][x + 2] = addError(buffer[y + 1][x + 2], errorR * 2, errorG * 2, errorB * 2);
                    }
                }
            }
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }

        // Алгоритм Sierra Lite
        function applySierraLite() {
            console.log("Применяем Sierra Lite");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            const buffer = new Array(h).fill().map(() => 
                new Array(w).fill().map(() => ({ r: 0, g: 0, b: 0 }))
            );
            
            // Заполняем буфер исходными значениями
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    if (PARAMS.dither.invertColors) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }
                    
                    buffer[y][x] = {
                        r: constrain(r, 0, 255),
                        g: constrain(g, 0, 255),
                        b: constrain(b, 0, 255)
                    };
                }
            }
            
            // Применяем дизеринг Sierra Lite
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const oldPixel = buffer[y][x];
                    const newPixel = {
                        r: oldPixel.r < 128 ? 0 : 255,
                        g: oldPixel.g < 128 ? 0 : 255,
                        b: oldPixel.b < 128 ? 0 : 255
                    };
                    
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = newPixel.r;
                    tempImg.pixels[i + 1] = newPixel.g;
                    tempImg.pixels[i + 2] = newPixel.b;
                    tempImg.pixels[i + 3] = 255;
                    
                    // Вычисляем ошибки
                    const errorR = (oldPixel.r - newPixel.r) / 4;
                    const errorG = (oldPixel.g - newPixel.g) / 4;
                    const errorB = (oldPixel.b - newPixel.b) / 4;
                    
                    // Распространяем ошибки по схеме Sierra Lite
                    if (x < w - 1) buffer[y][x + 1] = addError(buffer[y][x + 1], errorR * 2, errorG * 2, errorB * 2);
                    if (y < h - 1) {
                        if (x > 0) buffer[y + 1][x - 1] = addError(buffer[y + 1][x - 1], errorR, errorG, errorB);
                        buffer[y + 1][x] = addError(buffer[y + 1][x], errorR, errorG, errorB);
                    }
                }
            }
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }

        // Алгоритм JJN (Jarvis, Judice, and Ninke)
        function applyJJN() {
            console.log("Применяем JJN");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            const buffer = new Array(h).fill().map(() => 
                new Array(w).fill().map(() => ({ r: 0, g: 0, b: 0 }))
            );
            
            // Заполняем буфер исходными значениями
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    if (PARAMS.dither.invertColors) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }
                    
                    buffer[y][x] = {
                        r: constrain(r, 0, 255),
                        g: constrain(g, 0, 255),
                        b: constrain(b, 0, 255)
                    };
                }
            }
            
            // Применяем дизеринг JJN
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const oldPixel = buffer[y][x];
                    const newPixel = {
                        r: oldPixel.r < 128 ? 0 : 255,
                        g: oldPixel.g < 128 ? 0 : 255,
                        b: oldPixel.b < 128 ? 0 : 255
                    };
                    
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = newPixel.r;
                    tempImg.pixels[i + 1] = newPixel.g;
                    tempImg.pixels[i + 2] = newPixel.b;
                    tempImg.pixels[i + 3] = 255;
                    
                    // Вычисляем ошибки
                    const errorR = (oldPixel.r - newPixel.r) / 48;
                    const errorG = (oldPixel.g - newPixel.g) / 48;
                    const errorB = (oldPixel.b - newPixel.b) / 48;
                    
                    // Распространяем ошибки по схеме JJN
                    const weights = [
                        [1, 0, 7], [2, 0, 5],
                        [-2, 1, 3], [-1, 1, 5], [0, 1, 7], [1, 1, 5], [2, 1, 3],
                        [-2, 2, 1], [-1, 2, 3], [0, 2, 5], [1, 2, 3], [2, 2, 1]
                    ];
                    
                    for (const [dx, dy, weight] of weights) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            buffer[ny][nx] = addError(
                                buffer[ny][nx],
                                errorR * weight,
                                errorG * weight,
                                errorB * weight
                            );
                        }
                    }
                }
            }
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }

        // Шахматный дизеринг
        function applyChessboard() {
            console.log("Применяем Chessboard");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    // Шахматный паттерн
                    const isChessWhite = (x + y) % 2 === 0;
                    const threshold = isChessWhite ? 192 : 64;
                    
                    const newR = r < threshold ? 0 : 255;
                    const newG = g < threshold ? 0 : 255;
                    const newB = b < threshold ? 0 : 255;
                    
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = PARAMS.dither.invertColors ? 255 - newR : newR;
                    tempImg.pixels[i + 1] = PARAMS.dither.invertColors ? 255 - newG : newG;
                    tempImg.pixels[i + 2] = PARAMS.dither.invertColors ? 255 - newB : newB;
                    tempImg.pixels[i + 3] = 255;
                }
            }
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }

        // Вспомогательная функция для добавления ошибки к пикселю
        function addError(pixel, errorR, errorG, errorB) {
            return {
                r: constrain(pixel.r + errorR, 0, 255),
                g: constrain(pixel.g + errorG, 0, 255),
                b: constrain(pixel.b + errorB, 0, 255)
            };
        }

        // Вспомогательная функция для отрисовки масштабированного изображения
        function drawScaledImage(img, cellSize) {
            background(PARAMS.dither.invertColors ? 255 : 0);
            for (let y = 0; y < img.height; y++) {
                for (let x = 0; x < img.width; x++) {
                    const i = (y * img.width + x) * 4;
                    const c = color(
                        img.pixels[i],
                        img.pixels[i + 1],
                        img.pixels[i + 2]
                    );
                    noStroke();
                    fill(c);
                    rect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        // Создаем индикатор FPS
        function createFPSIndicator() {
            const fpsIndicator = document.createElement('div');
            fpsIndicator.className = 'fps-indicator';
            fpsIndicator.id = 'fps-indicator';
            fpsIndicator.textContent = 'FPS: 0';
            document.getElementById('canvas-container').appendChild(fpsIndicator);
        }
        
        // Обновляем FPS индикатор
        function updateFPS() {
            const now = performance.now();
            const delta = now - lastFrameTime;
            lastFrameTime = now;
            
            // Обновляем значение FPS (скользящее среднее)
            fps = 0.9 * fps + 0.1 * (1000 / delta);
            
            // Обновляем отображение FPS раз в секунду
            if (now - lastFpsUpdate > 500) {
                const fpsIndicator = document.getElementById('fps-indicator');
                if (fpsIndicator) {
                    fpsIndicator.textContent = `FPS: ${Math.round(fps)}`;
                    
                    // Изменяем цвет в зависимости от FPS
                    if (fps > 25) {
                        fpsIndicator.style.color = '#4caf50'; // Зеленый для хорошего FPS
                    } else if (fps > 15) {
                        fpsIndicator.style.color = '#ff9800'; // Оранжевый для среднего FPS
                    } else {
                        fpsIndicator.style.color = '#f44336'; // Красный для низкого FPS
                    }
                }
                lastFpsUpdate = now;
            }
            
            // Скрываем или показываем индикатор FPS в зависимости от настройки
            const fpsIndicator = document.getElementById('fps-indicator');
            if (fpsIndicator) {
                fpsIndicator.style.display = PARAMS.video.showFPS ? 'block' : 'none';
            }
        }
        
        // p5.js draw функция
        function draw() {
            // Обновляем счетчик FPS
            updateFPS();
            
            if (isVideoMode && video && video.loadedmetadata) {
                // Получаем текущий кадр видео
                img = video.get();
                
                // Если идет запись и включена оптимизация, сильно уменьшаем разрешение для повышения производительности
                if (isRecording && PARAMS.video.optimizeForRecording) {
                    // Временно уменьшаем масштаб дизеринга для ускорения обработки
                    const originalScale = PARAMS.dither.scale;
                    PARAMS.dither.scale = Math.max(4, originalScale * 2); // Увеличиваем размер ячеек для ускорения
                    
                    applyDither();
                    
                    // Восстанавливаем оригинальный масштаб
                    PARAMS.dither.scale = originalScale;
                } else {
                    applyDither();
                }
            }
        }
        
        function startRecording() {
            // Проверка поддержки MediaRecorder
            if (!MediaRecorder.isTypeSupported('video/webm;codecs=vp9') && 
                !MediaRecorder.isTypeSupported('video/webm')) {
                alert('Ваш браузер не поддерживает запись видео. Попробуйте Chrome или Firefox.');
                return;
            }

            recordedChunks = [];
            videoBlob = null;
            
            try {
                // Убедимся, что p5 обновляет холст, для видео нужно движение
                loop();
                
                // Проверка наличия канваса
                if (!canvas || !canvas.elt) {
                    console.error("Canvas не найден");
                    alert("Ошибка: Canvas не найден");
                    return;
                }
                
                // Если это Safari, используем альтернативный метод записи
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                if (isSafari) {
                    startFrameBasedRecording();
                    return;
                }
                
                // Используем FPS для записи вместо общего FPS
                const recordFps = Math.min(PARAMS.video.recordFps, 30); // Ограничиваем до 30 для надежности
                const stream = canvas.elt.captureStream(recordFps);
                console.log("Stream создан с FPS:", recordFps);
                
                if (!stream || !stream.getVideoTracks || stream.getVideoTracks().length === 0) {
                    console.error("Не удалось создать stream или получить видео треки");
                    startFrameBasedRecording();
                    return;
                }
                
                // Пробуем использовать VP9, если не поддерживается - fallback на стандартный кодек
                const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
                    ? 'video/webm;codecs=vp9' 
                    : 'video/webm';
                
                console.log("Используем MIME тип:", mimeType);
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 1500000 // 1.5 Mbps (снижаем для надежности)
                });
                
                console.log("MediaRecorder создан:", mediaRecorder);
                
                mediaRecorder.ondataavailable = function(e) {
                    console.log("Получены данные размером:", e.data.size);
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };
                
                mediaRecorder.onstart = function() {
                    console.log('Запись началась');
                    PARAMS.video.recordButtonText = '⚫ Остановить запись';
                    recordBtn.title = PARAMS.video.recordButtonText;
                    
                    // Показываем монитор длительности записи
                    recordingMonitor.element.style.display = 'block';
                    PARAMS.video.recordingDuration = 0;
                    
                    // Запускаем таймер обновления длительности
                    recordingTimer = setInterval(() => {
                        PARAMS.video.recordingDuration += 0.1;
                        recordingMonitor.refresh();
                    }, 100);
                    
                    // Убедимся, что видео играет во время записи
                    if (video && video.paused) {
                        video.play();
                        loop();
                    }
                };
                
                mediaRecorder.onstop = function() {
                    console.log('Запись остановлена, chunks:', recordedChunks.length);
                    clearInterval(recordingTimer);
                    PARAMS.video.recordButtonText = 'Записать видео';
                    recordBtn.title = PARAMS.video.recordButtonText;
                    recordingMonitor.element.style.display = 'none';
                    
                    if (recordedChunks.length === 0) {
                        console.error('Нет данных для сохранения, пробуем альтернативный метод');
                        // Если не получилось через MediaRecorder, пробуем запись кадрами
                        startFrameBasedRecording();
                        return;
                    }
                    
                    // Создаем blob и открываем предпросмотр
                    try {
                        videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                        
                        // Проверяем размер созданного blob
                        const sizeMB = (videoBlob.size / (1024 * 1024)).toFixed(2);
                        console.log('Размер видео:', sizeMB + ' МБ');
                        
                        if (videoBlob.size < 1000) { // Меньше 1KB вероятно пустой файл
                            console.error('Видео слишком маленькое, возможно пустое');
                            // Пробуем альтернативный метод
                            startFrameBasedRecording();
                            return;
                        }
                        
                        // Открываем предпросмотр
                        showVideoPreview(videoBlob);
                        
                    } catch (error) {
                        console.error('Ошибка при создании видео Blob:', error);
                        alert('Ошибка при создании видео: ' + error.message);
                    }
                };
                
                mediaRecorder.onerror = function(event) {
                    console.error('Ошибка записи:', event.error);
                    alert('Ошибка записи: ' + event.error);
                    stopRecording();
                };
                
                // Запись начинается с более крупным интервалом сбора данных для лучшей производительности
                mediaRecorder.start(1000); // Собираем данные раз в секунду для лучшей производительности
                isRecording = true;
                
            } catch (error) {
                console.error('Ошибка при создании MediaRecorder:', error);
                // Пробуем альтернативный метод
                startFrameBasedRecording();
            }
        }
        
        // Альтернативный метод записи через сохранение отдельных кадров
        function startFrameBasedRecording() {
            console.log("Используем запись на основе кадров (альтернативный метод)");
            
            // Максимальное количество кадров для записи (ограничиваем, чтобы не занять всю память)
            const maxFrames = 300; // ~10 секунд при 30fps
            let frames = [];
            let frameCount = 0;
            
            // Показываем индикатор длительности
            PARAMS.video.recordButtonText = '⚫ Остановить запись';
            recordBtn.title = PARAMS.video.recordButtonText;
            recordingMonitor.element.style.display = 'block';
            PARAMS.video.recordingDuration = 0;
            
            // Используем более низкую частоту кадров для записи
            const recordFps = Math.min(PARAMS.video.recordFps, 15); // Ограничиваем до 15 для надежности
            
            // Запускаем таймер для записи кадров с пониженным FPS
            const frameCapture = setInterval(() => {
                if (frameCount >= maxFrames) {
                    clearInterval(frameCapture);
                    clearInterval(recordingTimer);
                    finishFrameRecording();
                    return;
                }
                
                // Захватываем кадр с canvas, используя JPEG с более низким качеством
                frames.push(canvas.elt.toDataURL('image/jpeg', 0.5));
                frameCount++;
                
            }, 1000 / recordFps);
            
            // Обновляем счетчик времени
            recordingTimer = setInterval(() => {
                PARAMS.video.recordingDuration += 0.1;
                recordingMonitor.refresh();
            }, 100);
            
            // Устанавливаем флаг записи
            isRecording = true;
            
            // Запускаем видео и анимацию
            if (video && video.paused) {
                video.play();
                loop();
            }
            
            // Функция для создания видео из кадров
            function finishFrameRecording() {
                console.log("Завершаем запись кадров:", frames.length);
                
                PARAMS.video.recordButtonText = 'Записать видео';
                recordBtn.title = PARAMS.video.recordButtonText;
                recordingMonitor.element.style.display = 'none';
                isRecording = false;
                
                if (frames.length === 0) {
                    alert("Ошибка: не удалось записать ни одного кадра");
                    return;
                }
                
                // Создаем временный canvas для записи видео
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const ctx = tempCanvas.getContext('2d');
                
                // Создаем превью видео
                const previewContainer = document.getElementById('video-preview');
                const previewPlayer = document.getElementById('preview-player');
                const downloadBtn = document.getElementById('download-video');
                const closeBtn = document.getElementById('close-preview');
                
                // Создаем элемент для показа записанных изображений
                const imagePreview = document.createElement('div');
                imagePreview.style.width = '80%';
                imagePreview.style.height = '70%';
                imagePreview.style.overflow = 'hidden';
                imagePreview.style.position = 'relative';
                imagePreview.style.backgroundColor = '#000';
                imagePreview.style.marginBottom = '20px';
                
                // Добавляем изображение для предпросмотра
                const imgElement = document.createElement('img');
                imgElement.src = frames[0];
                imgElement.style.width = '100%';
                imgElement.style.height = '100%';
                imgElement.style.objectFit = 'contain';
                
                imagePreview.appendChild(imgElement);
                
                // Заменяем видео плеер на наш предпросмотр изображений
                previewPlayer.style.display = 'none';
                previewContainer.insertBefore(imagePreview, previewPlayer.nextSibling);
                
                // Показываем контейнер
                previewContainer.style.display = 'flex';
                
                // Создаем анимацию для предпросмотра
                let currentFrame = 0;
                const previewAnimation = setInterval(() => {
                    currentFrame = (currentFrame + 1) % frames.length;
                    imgElement.src = frames[currentFrame];
                }, 1000 / PARAMS.video.fps);
                
                // Обработчик для кнопки скачивания
                downloadBtn.innerText = 'Скачать WebM';
                downloadBtn.onclick = function() {
                    clearInterval(previewAnimation);
                    
                    // Создаем ZIP архив с изображениями
                    const zip = new JSZip();
                    
                    // Добавляем изображения в архив
                    frames.forEach((dataURL, index) => {
                        // Удаляем префикс из DataURL
                        const base64Data = dataURL.split(',')[1];
                        zip.file(`frame_${index.toString().padStart(5, '0')}.jpg`, base64Data, {base64: true});
                    });
                    
                    // Генерируем ZIP и скачиваем
                    zip.generateAsync({type: 'blob'}).then(function(blob) {
                        const filename = 'dithered_frames.zip';
                        downloadFile(blob, filename);
                    });
                };
                
                // Обработчик для кнопки закрытия
                closeBtn.onclick = function() {
                    clearInterval(previewAnimation);
                    previewContainer.style.display = 'none';
                    if (imagePreview.parentNode) {
                        imagePreview.parentNode.removeChild(imagePreview);
                    }
                    previewPlayer.style.display = '';
                    frames = [];
                };
            }
        }

        // Функция для показа предпросмотра видео и скачивания
        function showVideoPreview(blob) {
            const previewContainer = document.getElementById('video-preview');
            const previewPlayer = document.getElementById('preview-player');
            const downloadBtn = document.getElementById('download-video');
            const closeBtn = document.getElementById('close-preview');
            
            // Установить видео в плеер
            const videoUrl = URL.createObjectURL(blob);
            previewPlayer.src = videoUrl;
            previewPlayer.load();
            
            // Восстанавливаем исходный текст кнопки скачивания
            downloadBtn.innerText = 'Скачать видео';
            
            // Отображаем контейнер предпросмотра
            previewContainer.style.display = 'flex';
            previewPlayer.style.display = '';
            
            // Обработчик для кнопки скачивания WebM
            downloadBtn.onclick = function() {
                const filename = 'dithered-video-' + new Date().toISOString().slice(0, 19).replace(/:/g, '-') + '.webm';
                downloadFile(blob, filename);
            };
            
            // Обработчик для кнопки закрытия
            closeBtn.onclick = function() {
                previewContainer.style.display = 'none';
                URL.revokeObjectURL(videoUrl);
            };
        }

        // Добавляем функцию конвертации в MP4
        async function convertToMP4(webmBlob, videoUrl, filename) {
            const video = document.createElement('video');
            video.src = videoUrl;
            video.muted = true;
            
            try {
                // Ждем загрузки метаданных
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                    video.load();
                });
                
                // Создаем canvas для рисования кадров
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                
                // Создаем MediaRecorder для записи MP4
                const stream = canvas.captureStream(PARAMS.video.recordFps);
                
                // В современных браузерах h264 создает нативный MP4
                let options = {mimeType: 'video/mp4'};
                if (!MediaRecorder.isTypeSupported('video/mp4')) {
                    options = {mimeType: 'video/webm; codecs=h264'};
                    if (!MediaRecorder.isTypeSupported('video/webm; codecs=h264')) {
                        // Для Safari и других браузеров пробуем другие форматы
                        alert('Ваш браузер не поддерживает кодирование в MP4, попробуйте Chrome или Firefox');
                        throw new Error('Браузер не поддерживает MP4 кодирование');
                    }
                }
                
                const recorder = new MediaRecorder(stream, {
                    ...options,
                    videoBitsPerSecond: 1500000 // Снижаем битрейт для лучшей производительности
                });
                const chunks = [];
                
                // Собираем данные
                recorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };
                
                // Функция, выполняемая при завершении записи
                const recorderPromise = new Promise((resolve, reject) => {
                    recorder.onstop = () => {
                        try {
                            const mp4Blob = new Blob(chunks, {type: 'video/mp4'});
                            downloadFile(mp4Blob, filename, true);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    };
                    
                    recorder.onerror = reject;
                });
                
                // Запускаем запись
                recorder.start(1000);
                
                // Запускаем видео
                video.currentTime = 0;
                await new Promise(resolve => {
                    video.oncanplay = resolve;
                    video.play();
                });
                
                // Используем более простой подход с setTimeout
                const frameTime = 1000 / Math.min(15, PARAMS.video.recordFps);
                let frameInterval = setInterval(() => {
                    // Рисуем текущий кадр
                    if (!video.ended && !video.paused) {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    } else {
                        // Видео закончилось
                        clearInterval(frameInterval);
                        recorder.stop();
                    }
                }, frameTime);
                
                // Добавляем проверку для остановки при завершении видео
                video.addEventListener('ended', () => {
                    clearInterval(frameInterval);
                    recorder.stop();
                    video.pause();
                });
                
                return recorderPromise;
            } catch (error) {
                console.error("Ошибка при конвертации MP4:", error);
                throw error;
            }
        }

        // Улучшенная функция скачивания файла
        function downloadFile(blob, filename, forceDownload = false) {
            try {
                console.log(`Скачивание файла ${filename}, размер: ${(blob.size / 1024 / 1024).toFixed(2)} МБ`);
                const a = document.createElement('a');
                const url = URL.createObjectURL(blob);
                a.href = url;
                a.download = filename;
                
                // Для MP4 добавляем атрибуты для лучшей совместимости
                if (filename.endsWith('.mp4') || forceDownload) {
                    a.setAttribute('download', filename);
                }
                
                document.body.appendChild(a);
                a.click();
                
                // Даем браузеру время обработать скачивание
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 150);
            } catch (e) {
                console.error("Ошибка при скачивании файла:", e);
                alert(`Ошибка при скачивании: ${e.message}`);
            }
        }

        // Вспомогательная функция для преобразования dataURI в Blob
        function dataURItoBlob(dataURI) {
            const byteString = atob(dataURI.split(',')[1]);
            const mimeType = dataURI.split(',')[0].split(':')[1].split(';')[0];
            
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            return new Blob([ab], {type: mimeType});
        }

        // Обновляем функцию stopRecording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                try {
                    console.log("Останавливаем запись...");
                    mediaRecorder.stop();
                } catch (error) {
                    console.error('Ошибка при остановке записи:', error);
                    alert('Ошибка при остановке записи: ' + error.message);
                }
                isRecording = false;
            }
        }

        // Загружаем JSZip при инициализации
        window.addEventListener('load', function() {
            checkMediaRecorderSupport();
            loadJSZip().catch(console.error);
            
            // Добавить обработчики событий для предпросмотра, если элементы существуют
            const closeBtn = document.getElementById('close-preview');
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    document.getElementById('video-preview').style.display = 'none';
                });
            }
        });

        // Добавление функции для проверки поддержки MediaRecorder при загрузке страницы
        function checkMediaRecorderSupport() {
            if (typeof MediaRecorder === 'undefined') {
                console.warn('Браузер не поддерживает MediaRecorder API');
                return false;
            }
            
            if (!MediaRecorder.isTypeSupported('video/webm') && 
                !MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                console.warn('Браузер не поддерживает формат WebM для записи');
                return false;
            }
            
            return true;
        }

        // Добавляем JSZip для сжатия изображений
        function loadJSZip() {
            if (window.JSZip) return Promise.resolve();
            
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = () => reject(new Error('Не удалось загрузить JSZip'));
                document.head.appendChild(script);
            });
        }

        // Алгоритм Voronoi
        function applyVoronoi() {
            console.log("Применяем Voronoi");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            // Создаем точки Вороного (случайные центры)
            const numPoints = Math.max(5, Math.floor((w + h) / 4));
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: random(w),
                    y: random(h),
                    threshold: random(64, 192)
                });
            }
            
            // Обрабатываем каждый пиксель
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    // Находим ближайшую точку Вороного
                    let minDist = Infinity;
                    let closestPoint = points[0];
                    
                    for (const point of points) {
                        const dx = x - point.x;
                        const dy = y - point.y;
                        const dist = dx * dx + dy * dy;
                        if (dist < minDist) {
                            minDist = dist;
                            closestPoint = point;
                        }
                    }
                    
                    // Применяем порог из ближайшей точки
                    const threshold = closestPoint.threshold;
                    const newR = r < threshold ? 0 : 255;
                    const newG = g < threshold ? 0 : 255;
                    const newB = b < threshold ? 0 : 255;
                    
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = PARAMS.dither.invertColors ? 255 - newR : newR;
                    tempImg.pixels[i + 1] = PARAMS.dither.invertColors ? 255 - newG : newG;
                    tempImg.pixels[i + 2] = PARAMS.dither.invertColors ? 255 - newB : newB;
                    tempImg.pixels[i + 3] = 255;
                }
            }
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }

        // Алгоритм Maze (лабиринтный дизеринг)
        function applyMaze() {
            console.log("Применяем Maze");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            // Создаем шум Перлина для базового лабиринта
            const noiseScale = 0.1;
            const mazeThreshold = 0.5;
            
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    // Генерируем лабиринтный паттерн
                    const noiseVal = noise(x * noiseScale, y * noiseScale);
                    const mazeVal = noiseVal > mazeThreshold ? 1 : 0;
                    
                    // Комбинируем яркость изображения с лабиринтом
                    const brightness = (r + g + b) / (3 * 255);
                    const threshold = mazeVal ? 0.6 : 0.4;
                    
                    const newValue = brightness > threshold ? 255 : 0;
                    
                    const i = (y * w + x) * 4;
                    tempImg.pixels[i] = PARAMS.dither.invertColors ? 255 - newValue : newValue;
                    tempImg.pixels[i + 1] = PARAMS.dither.invertColors ? 255 - newValue : newValue;
                    tempImg.pixels[i + 2] = PARAMS.dither.invertColors ? 255 - newValue : newValue;
                    tempImg.pixels[i + 3] = 255;
                }
            }
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }

        // Алгоритм Pixel Sorting
        function applyPixelSorting() {
            console.log("Применяем Pixel Sorting");
            
            const cellSize = Math.max(1, parseInt(PARAMS.dither.scale));
            const w = Math.floor(width / cellSize);
            const h = Math.floor(height / cellSize);
            
            const tempImg = createImage(w, h);
            tempImg.loadPixels();
            
            // Создаем массив пикселей для сортировки
            const pixels = [];
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const imgX = Math.min(img.width - 1, Math.floor(x * img.width / w));
                    const imgY = Math.min(img.height - 1, Math.floor(y * img.height / h));
                    const c = img.get(imgX, imgY);
                    
                    let r = red(c) * PARAMS.image.brightness;
                    let g = green(c) * PARAMS.image.brightness;
                    let b = blue(c) * PARAMS.image.brightness;
                    
                    r = (r - 128) * PARAMS.image.contrast + 128;
                    g = (g - 128) * PARAMS.image.contrast + 128;
                    b = (b - 128) * PARAMS.image.contrast + 128;
                    
                    if (!PARAMS.dither.useColor) {
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        r = g = b = gray;
                    }
                    
                    pixels.push({
                        x: x,
                        y: y,
                        brightness: (r + g + b) / 3,
                        color: { r, g, b }
                    });
                }
            }
            
            // Сортируем пиксели по яркости
            pixels.sort((a, b) => a.brightness - b.brightness);
            
            // Применяем отсортированные значения с порогом
            const threshold = 128;
            pixels.forEach((pixel, index) => {
                const i = (pixel.y * w + pixel.x) * 4;
                const val = pixel.brightness < threshold ? 0 : 255;
                
                tempImg.pixels[i] = PARAMS.dither.invertColors ? 255 - val : val;
                tempImg.pixels[i + 1] = PARAMS.dither.invertColors ? 255 - val : val;
                tempImg.pixels[i + 2] = PARAMS.dither.invertColors ? 255 - val : val;
                tempImg.pixels[i + 3] = 255;
            });
            
            tempImg.updatePixels();
            drawScaledImage(tempImg, cellSize);
        }
    </script>
</body>
</html> 